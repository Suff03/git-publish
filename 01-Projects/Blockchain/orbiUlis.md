
게시글 주소: https://orbi.kr/00012313138 

안녕하세요 예에에엣날에 컴퓨터 관련 글을 좀 끼적였던 개발자입니다. 이거저거 써보려다가 뭔가 일이 바빠지는 바람에 지지부진하게 돼버렸던 기억이 있네요...죄송...

요새 블록체인이 핫해서 공부를 좀 하던 차에 여기에도 관심있는 분들이 있을 것 같아 글을 쓰면 도움이 될까 해 몇부작으로 글을 좀 써볼까 합니다. (수능정도에 비문학 지문으로 나와주면 제일 도움이 되려나요...ㅎㅎ)

기초적인 내용부터 약간 기술적으로 심화된 내용까지 다뤄볼 생각입니다. 본인 관심도에 맞게 적당히 골라서 읽어주세요. 물론 암호화 알고리즘 등에 대해 깊이 들어가지는 않습니다. 누구라도 지루하거나 머리아프지 않게 읽을 수 있는 글이 목표에요.
  
그냥 공부하면서 알게된 것들에 대해 써보자 생각하고 키보드부터 두드리는거라 몇부작으로 할지, 어디에 뭔 내용이 들어갈 지 아직은 정리가 덜 돼있습니다. 뭔가 좀 체계가 없어 보이더라도 교양수업 듣는다 생각하고 가볍게 봐주시면 감사하겠습니다.

**이 글은 암호화폐와 그 근간을 이루고 있는 블록체인에 대해 살펴보는 글이지 비트코인과 이더리움 시장을 예측해 투자 타이밍을 조언하는 글이 아님을 알려드립니다. 이걸 본다고 투자하는데 도움이 되지 않습니다. 기술은 개발자에게 투자는 주갤러에게.**

**1. 비트코인? 이더리움?**

비트코인이 요새 많이 핫합니다. 비슷한걸로 이더리움이라는 것도 핫합니다. 그게 뭔지는 잘 모르겠지만 랜섬웨어 걸리면 해커들이 비트코인을 내놓으라고 합니다. 인터넷나야나가 12억인가를 비트코인으로 내주고 해커한테 복호화 키를 받았다고도 합니다. 대충 찾아보니 **암호화폐**라고 합니다. 뭐가 **분산**돼있고 **블록이 체인**을 이루고 있어 **조작도 불가능**하고 **장부가 공개**돼있어 누구나 볼 수 있다고 합니다. 뭐 말만 들어서는 약간 만병통치약같기도 하네요. 보통 이렇게 약을 파는건 문제가 있는건데, 이게 뭘까요?

비트코인은 2008년 **사토시 나카모토**라는 필명의 누군가가(아직도 누군지 모릅니다. 개인인지 조직인지도요. 지금은 아주 종적을 감추고 활동을 안해 진실은 저 너머로...) 발표한 [Bitcoin: A Peer-to-Peer Electronic Cash System](https://bitcoin.org/bitcoin.pdf) 이라는 페이퍼를 기반으로 발표한 **암호화 가상화폐**입니다. 암호화라는 것은 말 그대로 돈이 암호화되어있어 특정인이 소유주임을 증명할 수 있다는 말이고, 가상화폐는 우리가 눈으로 볼 수 있는 실체가 존재하지 않는다는 뜻입니다. 동전도 지폐도 통장도 없습니다. 인출도 할 수 없고 구경도 할 수 없죠. 그런데 이런 존재하지도 않는 것 같은 게 왜 이렇게 대단한 대접을 받고 있을까요?

**2. 블록체인(BlockChain)**

비트코인은 블록체인이라는 시스템을 이용하고 있습니다. 블록체인은 블록이 체인을 이루고 있는 겁니다. 네 농담 아니고 진지합니다. 왜 이게 대단한건지는 앞으로 글을 읽으시면 느끼실 거라 생각합니다. 전 처음에 이거 공부하면서 소름이 자꾸 돋더라구요. 공돌이라 그런지... 몇 가지 중요한 블록체인의 속성을 짚고 시작하면 앞으로 도움이 될 것 같네요.

1. 여러 개의 기록되어야 하는 정보는 블록이라는 형식의 데이터 안에 담긴다.

2. 이전 블록의 내용이 다음 블록에 담겨 블록간에 연결(체인)을 이룬다.

3. 블록을 완성하기 위해서는 문제를 풀어야 하며, 블록의 내용이 변경되면 문제를 다시 풀어야 한다.

4. 블록을 만들고자 하는 사람들은 같은 블록을 생성하기 위해 경쟁하며, 맨 먼저 블록을 완성한 사람은 보상을 받는다.

5. 블록 또는 블록체인의 유효성은 분산되어 있는 노드들의 다수결 투표로 검증된다.

뒤로 갈수록 뭔소린지 모르겠다 그죠? 알겠는 사람들도 의문점이 한둘이 아니다 그죠? 저도 공부하기 전에는 그랬습니다. 무슨 문제를 푼다는 것이며, 뭔 경쟁을 한다는 것인지, 갑자기 웬 다수결이 나오는지... 하나씩 차근차근 읽다보면 제가 그랬듯 한순간 돈오의 순간이 오시리라 기대하며 다음 글부터 한걸음씩 안으로 들어가보도록 하겠습니다.
  

**1. Make Transaction**

기본적으로 블록체인은 각종 **Transaction**들의 연속연속입니다. 모든 것은 Transaction으로 이루어져 있다고 할 수 있죠. 위 그림에서 User1이 User2에게 비트코인을 보냈다고 해보죠. 그럼 녹색 네모 안에 적힌 것 같은 정보가 담긴 Transaction 데이터가 생성됩니다. 그리고 이 정보는 User1에 연결되어 있는 피어들에게 전달됩니다. **블록체인 네트워크는 P2P 네트워크**로 이루어져있기 때문에 이런식으로 새로 생긴 정보는 네트워크를 따라 모든 노드들에게 공유됩니다. **이 시점에서 아직 User1, 2는 이 거래가 검증되었다는 것을 확인할 수 없습니다.**

**2. Receive Tx. and Pooling**

노드는 새로운 정보를 받으면 이를 검증하고 유효할 경우 또다른 노드에 전달하는 작업을 자동으로 진행합니다. 그 중에 특별하게 **Full Node**라는 녀석들이 있는데, 이 녀석들은 지금까지의 모든 블록체인 데이터를 가지고 있으면서, 독립적으로 거래를 검증할 수도 있으며, 새로운 거래도 모두 저장을 하고, 이를 가지고 새로운 블록도 만들어낼 수 있습니다. 노드 얘기는 다음에 다시 하고, Full Node가 새로운 거래를 전달받으면 이게 유효한 거래인지를 검증합니다(사용자 정보가 정확한지, 거래량이 잘 맞는지, 보낸사람의 잔고가 거래에 적합한지 등). 그리고 유효한 거래임이 확인되면 이 정보를 다른 노드에 전파하고 자신이 가진 **Tx. Pool 안에 저장**합니다.

**3. Make New Block(Mining)**

블록체인의 핵심 활동인 마이닝입니다. N-1번 블록이 어딘가에서 생성되어 이 정보가 우리 노드에 전달되었다고 합시다. 그러면 노드는 즉시 **N번 블록을 생성**하기 시작합니다. 새 블록을 만들기 위해 **Tx. Pool 안에서 적당한 거래들을 골라** 블록 안에 채워넣습니다. 블록의 구조는 Miner 안의 네모처럼 생겼습니다. 블록 안에 든 단어들이 뭘 의미하는지는 다음에 자세히 살펴보도록 하고, 지금은 **Hash**라는 단어 하나에만 집중하도록 합시다. 위와 같은 정보를 가지고 마이너는 **특정 조건을 만족하는 Block Hash를 만들어**내기 위해 노력합니다(보통 문제를 푼다고 표현하죠). 그렇게 Block Hash를 찾아내면 노드는 유레카를 외치며 완성된 블록 정보를 다른 노드들에게 전파합니다. User1, 2가 새로 생긴 블록 정보를 받게 되면 거기에 자신의 거래가 포함되어 있는지 확인합니다. 만일 **방금 생긴 블록에 자신의 거래가 포함되어 있으면 1번의 검증을 받았다**고 합니다. 보통 가벼운 거래의 경우 이것만으로 거래가 성사되었다고 판단합니다. 고가의 거래 또는 안정성이 매우 중요한 거래인 경우에는 최대 6번의 승인을 받기까지 기다리는데, 이는 다음에 거래 검증에 대한 얘기를 하면서 좀 더 자세히 썰을 풀어보도록 하겠습니다.

블록체인은 위의 3개의 단계가 여기저기서 막 일어나면서 길게 이어집니다. 그림을 그릴때는 간단히 설명할 수 있을 거라 생각했는데 글을 써놓고 보니 또 주절주절 떠들었네요. 아직도 기술적 글쓰기 실력이 부족함을 느낍니다. 

에... 아직까지는 뭔소린지 이해가 잘 안 가시는 분들도 많을 것 같네요. 일단 이게 어떻게 되는지 두루뭉술한 그림이라도 머릿속에서 그리실 수 있다면 이번 글을 잘 따라오셨다고 생각합니다. 좀 더 상세한 내용들을 채우면서 의문가는 부분, 헷갈리는 부분들이 구체화될 수 있도록 노력하겠습니다.

안녕하세요 하루가 멀다하고 옯질하는 직장인입니다. 걸리면 혼납니다.

지난 글에서 드디어 블록체인의 구조를 살펴봤습니다. 아직은 뭐가 어떻게 되는지 잘 모르는 부분도 많이 있을 것 같은데요, 오늘부터는 그 안을 좀 더 디테일하게 까보려고 합니다.

  

오늘 살펴볼 부분은 아래 그림에서 가장 큰 네모인 Node 라는 것입니다.

![](https://s3.orbi.kr/data/file/united2/02de9f27-feb1-49d5-b53a-3d584332af47bc_struct.png)

그림 절반을 차지하고 있는 커다란 네모가 모두 Node인데요, 뭔가 설명할 게 굉장히 많습니다만 일단 Miner 에 대한 얘기는 좀 빼놓고 설명드릴게요. 잘게 쪼개서 진행하는 게 글도 짧고 보기도 좋을 것 같네요.

  

**1. What is Node?**

노드란 건 별 것 없습니다. 그래프 배우시죠 수학시간에? 그래프는 Node, Edge로 이루어진다고 배우셨을 겁니다. 앞서 말씀드렸듯 블록체인 네트워크는 P2P 네트워크로, 망형 구조를 이루고 있습니다(이거 컴퓨터?정보? 시간에 배우나 모르겠네요). 수많은 비트코인 클라이언트가 Node가 되고, 그 사이를 잇는 네트워크가 Edge가 되는 식이죠. 물론 컴퓨터 사이에 직접 인터넷 선을 놓는 것은 아니지만 위상은 동일합니다.

  

**2. Node의 종류**

이 노드에는 여러 종류가 있습니다. 먼저 우리가 2편에서 만들어봤던 거래소에 계좌를 트는 것을 생각해보겠습니다. 거래소 홈페이지에서 계좌를 만들면 거기에서 계좌 정보를 볼 수 있죠? 그런데 그걸 만들려고 우리 컴퓨터에 뭔가 설치하는 단계가 있었나요? 또는 그 계좌를 제 컴퓨터에 가져와 별도의 프로그램으로 볼 수 있었나요? 아니죠? 이런식으로 웹에서만 쓸 수 있고 대개는 어딘가에서 관리되고 있는 노드를 Web Node 라고 합니다. 제일 가볍고 간편하지만 통제권이 제게 1도 없다는 단점이 있죠. 보통의 유저들에게는 전혀 단점이 아니기는 해요.

  

다음으로, 우리가 뭔가 프로그램을 다운받아 거기에 계좌를 등록해서 볼 수 있는 것들이 있습니다. 블록체인 앱이나 이더리움 지갑 앱 같은 것들을 생각하면 되겠네요. 이런 것들은 계좌 정보를 가지고 있고 지금 해당 코인의 블록체인이 얼마나 이어졌는지도 알고 있으며, 거래를 검증할 수도 있습니다. 하지만 거래를 스스로 검증하지는 못하고 간접적인 방법으로 증명할 수 밖에 없어요. 따라서 거래 검증을 위해서는 네트워크 연결이 필요합니다. 이런 노드를 가볍다고 해서 Lightweight Node 라고 합니다. 얘들은 보통 블록 헤더만을 가지고 있어요. 그래서 상대적으로 용량도 적게 차지하고 기능도 많지 않지요.

  

마지막으로 0번 블록부터 지금까지의 모든 블록을 다 저장하고 있으며, 새로운 블록도 생성할 수 있고 다른 Lightweight Node가 요청한 거래 검증을 해줄 수 있는, 심지어 그 누구의 도움 없이도 스스로 거래를 검증해낼 수 있는 노드가 있습니다. 이게 바로 위 그림에 있기도 하고, 3편에서 예를 들었던 Full Node 입니다. 얘도 인터넷에서 받아서 사용할 수 있어요. 많은 데스크탑용 클라이언트가 Full Node입니다. 얘는 모든 기능을 다 가지고 있는 장점이 있지만 0번부터 지금까지의 모든 블록 정보를 저장해야 하기 때문에 저장공간이 어마어마하게 필요해요. 비트코인의 경우 지금 어림잡아 30GB 이상의 공간이 상시 필요할겁니다. 이더리움의 경우에도 수 GB정도 필요할거에요. 이 공간은 블록체인이 길어질수록 지속적으로 증가하게 되기 때문에 저장공간이 아아아아주 넉넉하신 분이 아니라면, 그리고 마이닝이니 뭐니 하는 고오급 기능이 필요하지 않다면 Full Node 사용을 추천하지 않습니다. 그냥 용량 잡아먹는 괴물이에요 이거.

  

**3. Node 의 구성**

Web, Lightweight Node는 별로 하는 일이 없기 때문에(Lightweiget Node의 거래 검증은 별도 설명이 필요합니다만) Full Node 기준으로 설명드리도록 하겠습니다. Full Node는 크게 Tx. Pool, Block Pool, BlockChain Storage, Wallet, Block Generator/Miner, P2P Network Client 등으로 구성되어있다고 볼 수 있습니다. 세세하게 나누자면 저 중에 뭘 가지고 있느냐에 따라 이름이 또 갈리기도 하고 그렇습니다만, 모든 기능을 다 하는 Reference급 노드라면 저런 것들을 모두 가지고 있습니다. 

BlockChatin Storage는 이름만 봐도 알겠죠? 그냥 0번부터 지금까지의 모든 블록체인을 저장하고 있는 저장소입니다. 이 체인은 P2P Network를 통해 새로운 블록을 전달받으면 계속 길어져 저장되겠죠. 가끔 여러 블록이 매우 빠른 속도로 채굴되는 경우가 있는데 이 경우 N+1번 블록보다 N+2번 블록이 더 빨리 내게 도달하는 경우가 있습니다. 이런 경우 N+2번 블록은 N+1번 블록이 도착하기 전까지 고아 블록이 되어 Block Pool에 머무르게 됩니다. Tx. Pool은 저번 글에서 설명드렸듯 유효함을 확인받은 거래이나 아직 블록에 기록되지 않은(검증받지 못한) 거래들을 저장하는 곳이구요. 지갑은 말 그대로 블록체인 주소를 가지고 있으며, 이 주소를 통해 코인을 주고받을 수 있습니다. 이 주소를 만들어내기 위한 개인키가 없으면 이 지갑을 열 수가 없으니 개인키 관리에 주의가 필요해요. 그리고 Block Generator는 사실 뭐 Miner라고 봐도 무방할 것 같은데, 이전 블록 정보와 Tx. Pool에서 적당히 선별한 거래들을 모아서 새로운 블록을 만드는 일을 합니다. 그렇게 만들어낸 블록 정보는 P2P Network를 통해 전파하구요.

  

이번 글에서는 블록체인 네트워크를 구성하는 요소 중 Node에 대해 알아봤습니다. 지구상에 쫙 깔려있는 수많은 노드들이 다 네트워크를 이루는 요소들이 되구요, 그 중에 Full Node들은 각자가 독립적으로 자신만의 저장소에 블록체인을 저장하고 있습니다. 블록체인의 특징 중 하나인 중앙 통제기관 없는 분산장부(블록은 거래를 기록하고 있으니 장부라고 볼 수 있겠죠)를 만들어내는 주인공이죠. 아직 블록체인이 뭐 왜 체인인지도 설명 안해주고 빨리 마이닝 하는거 어떻게 하는지 궁금하신 분들이 많은텐데 이제 슬슬 본격 설명을 위한 떡밥을 다 깐 것 같습니다. 다음 글부터는 내용이 재밌어지길 바라며, 다음 글에서 뵙겠습니다.

안녕하세요 벌써 다섯번째 글이네요. 처음 시작할때는 글 다섯개정도면 끝날 줄 알았는데 아직도 못 쓴 내용이 너무 많네요. 10편까지는 써야 할 것 같기도 하고... 여튼 완결까지 열심히 달려보도록 하겠습니다. 이번 글은 쓰다보니 내용이 자꾸 깊어지는 것 같아서 어떻게 조절해야하나 고민하다 보니 텀이 길어졌습니다. 앞으로 계속 어려워질 것 같은게 함정...

저번 글에서는 블록체인을 만들어내는 노드에 대해 설명을 드렸는데, 이번 글에서는 그렇게 노드에서 만들어내는 블록이 어떻게 해서 체인을 이루고 있는지, 그렇게 체인을 이루고 있음으로 해서 어떤 특징들이 또 있는지 알아보도록 하겠습니다.

  

**1. Block**

일단 블록이 어떻게 생겼는지 그 구조를 알아보도록 하겠습니다. 이전 글에서 봤던 그림에 보면 블록이 가진 정보는 다음과 같습니다.

**Prev. Hash / Nonce / Timestamp / Difficulty / Merkle Root   //   Tx. Infos**

// 를 기준으로 앞에 있는 녀석들을 묶어서 **Block Header** 라고 하고 뒤에 있는 것을 **Block Body** 라고 합니다. 간단하니 Body를 먼저 설명 드릴게요. 여기에는 지난 글에서도 설명드렸듯 Tx. Pool에서 고른 거래들이 들어갑니다. 거래를 고르는 기준은 각 노드가 자기 맘대로 설정할 수 있는데, 보통은 풀에 들어와 머무른 시간과 거래에 딸린 수수료 등을 기준으로 합니다. 1편인가 2편에서 어떤 거래는 검증되기까지 한시간씩 걸리기도 한다는 말씀을 드렸었는데요, 이게 바로 그 이유에요. 수수료를 낮게 책정하면 새 블록 안에 포함될 확률이 낮아지기 때문에 오랜 시간 블록에 들어가지 못하고 계속 풀에서 기다려야 하죠. 그러다보면 검증을 받을 때까지 오래걸리는거에요. 뭐 이 안에 거래정보만 들어가는게 아니라 그걸로 만든 거래 해시값이라거나 하는 것들도 들어가기는 하는데, 그건 나중에 머클트리에 대해 설명할 때가 되면 다시 짚도록 하고, 블록 헤더가 중요하니 그걸 쭉 훑어보겠습니다.

  

**2. Block Header**

블록 헤더에 든 것들을 한개씩 살펴보죠.

**1. Prev Hash** : 이건 이전 블록의 해시값을 말하는거에요. 이전 블록의 해시가 다음 블록에 포함되기 때문에 블록이 체인을 이룬다고 하는거에요. 이전블록의 해시를 가지고 있기 때문에 어떤 블록 하나를 알면 그것보다 과거의 블록은 전부(그러니까 0번 블록까지) 거슬러 올라갈 수 있어요.

**2. Timestamp** : 이 블록이 언제 생성됐는지를 알려주는 타임스탬프입니다. 보통 시차랑 블록이 전파되는데 걸리는 시간을 고려해 두시간정도까지 오차를 허용하고 있다고 해요. 이 이상 타임스탬프가 멀리 차이나면 다른 노드에서 이 블록을 검증할 때 유효하지 않다고 판단하고 거절해버립니다.

**3. Nonce** : 한번 쓰인 숫자(Number + Once) 의 줄임말이라고 합니다. 블록 해시를 찾는데 쓰이는 부분이에요. 정확히 어떻게 쓰는지는 밑에서 설명드릴게요.

**4. Difficulty** : 문제의 난이도를 뜻합니다. 비트코인은 평균 10분에 한번씩 새 블록이 채굴되는 것을 목표로 하고 있어요. 그래서 대략 4년(21만블록정도)에 한번씩 그간 생성된 블록들의 생성시간을 살펴보고 난이도를 조절합니다. 이 난이도 조절은 모든 Full Node에서 같은 수식에 따라 독립적으로 적용돼요. 요것도 아래에서 블록을 생성하는 과정을 설명드리면서 한번 더 등장할겁니다.

**5. Merkle Root** : 되게 처음보는 이름이죠? 머클 루트라고 읽는데, 이건 Lightweight Node에서 거래 검증을 하는데 쓰기 위해 있는 녀석이에요. Block Body 안에 있는 Tx. 정보를 압축한 해시값이라고 보시면 됩니다.

  

**3. Hash? HASH?**

자꾸 1편부터? 여튼 해시라는 말이 자꾸 나오는데 이게 글을 쓰다 보니 당연히 알 거라고 생각하고 자연스레 넘어갔던 것 같네요. **HASH 라는건 쉽게 설명하면 어떤 입력값이든 고정 길이의 결과값으로 바꿔주는 함수**에요. 보통 비트코인에서는 **SHA256**이라는 해시함수를 쓰는데, 뭐든지 여기에 통과시키면 길이가 256인 결과값이 나옵니다. 같은 입력값을 넣으면 항상 같은 출력값이 나와요. 그런데 해시값을 안다고 원래 입력값을 알아낼 수는 없어요. 왜냐하면 가능한 입력값의 갯수보다 출력값의 갯수가 적기 때문이죠. 뭐 이런걸 두고 전문용어(?)로는 단사함수가 아니라고 한다네요. 어쩔 수 없이 같은 해시값을 가지는 둘 이상의 입력값이 존재할 수밖에 없어요. 하지만 그건 매우매우매우매우 드물게 일어나는 일이기 때문에 보통은 입력값이 다르면 출력값도 다르다고 할 수 있죠. 해시암호의 큰 이슈중 하나가 Collision인데, 아직까지 그런 면에서 SHA256은 안전하다고 평가받고 있어요. 그리고 복잡한 함수를 통과하기 때문에 입력값이 약간만 변해도 결과 해시는 크게 변해요. 그래서 해시값은 예측이 불가능하다고도 합니다. 간단하게 정리하자면 **해시는 입력값에 1:1로 대응되는 함수 결과값이고, 예측가능성이나 규칙이 존재하지 않는다**고 할 수 있겠네요.

  

**4. Find Block Hash**

블록을 만드는 과정은 블록 해시를 찾는 과정이라고 저번에 말씀드린 적이 있을 거에요. 위에서 말씀드렸던 **해시함수를 이용해 특정 조건을 만족하는 해시값을 찾는 작업**이 바로 블록 해시를 찾는 과정입니다. 그 조건이 바로 Difficulty인데, 이것보다 작은 해시값을 찾으면 블록 생성에 성공하는거에요. 물론 답은 하나가 아니겠죠? Difficulty보다 작은 해시는 많이 있을테니까요. 앞에서 말씀드렸듯 해시값은 규칙이나 예측가능성이 없기 때문에 **일일이 대입**해보면서 확인하는 것밖에 방법이 없어요. 그런데 이전 헤더, 타임스탬프, 머클트리같은 것들은 값을 변경할 수가 없거나 한계가 있죠? 그래서 있는게 **Nonce** 라는 값이에요. 이걸 바꿔가면서 조건에 맞는 해시값을 찾아가는거죠. 난이도 조절은 Difficulty 값을 변경하는 것으로 이루어지는데, 난이도를 올리려면 Difficulty 안에 담긴 값을 작게 만들고(이것보다 작은 해시를 찾아야 하니까요) 내리려면 숫자를 크게 만듭니다. 보통 어려운 수학문제를 푸는 과정이라고 블록을 만드는 과정을 설명하는데, 사실 그게 아니라 그냥 열심히 대입해가면서 무작위로 찾아보는거... **Brute Force** 라고 합니다 저런걸........... 뭐 되게 별거 아닙니다. 그냥 대입해봐야 될 경우의 수가 너무 많을 뿐... 

그렇게 Nonce를 막 바꿔가면서 해시값을 뒤적여봅니다. 전 세계의 Full Node 또는 Miner가 이런 걸 열심히 찾겠죠? 그러다가 누군가가 조건에 맞는 해시를 찾아내면 Nonce 자리에 자신이 답을 찾는데 사용한 Nonce를 박아서 블록을 완성하고 이 블록+찾아낸 해시 정보를 주변 노드에 전파합니다. 그리고 블록을 만들어낸 보상으로 일정량의 비트코인을 받게 되구요(보상은 초기에는 블록당 50BTC에서 시작해서 2016년에는 12.5BTC가 되었습니다. 일정 주기로 절반씩 줄어들어 2140년경에 2100만BTC가 모두 채굴된다고 하네요). 주변 노드에서는 새 블록이 생겼다는 정보를 받으면 그 블록 헤더와 전달받은 해시를 가지고 답이 맞는지 검증합니다. 이 과정은 답을 찾아내는게 아니라 이미 찾은 답을 확인하는 것이기 때문에 HASH 연산을 한번만 해보면 돼요. 그렇게 검증을 통과한 블록은 블록체인에 연결되게 되고, 노드들은 다시 이 블록 해시와 Tx. Pool에서 건진 거래를 가지고 다음 블록을 생성합니다. 이렇게 블록이 영원히 체인이 되어 이어집니다.

  

이번 글에서는 블록의 구성과 그 블록을 어떻게 생성하고, 어떻게 체인에 연결되는지를 살펴보았습니다. 사실 이게 블록체인의 핵심이에요. **거래를 담은 블록을 만들어내서 체이닝한다**. 이 글까지 읽으신 분들께서는 이 그림을 다시 보시면 한눈에 어떻게 돌아가는지 이해가 가실거라 생각합니다.

![](https://s3.orbi.kr/data/file/united2/7a484819-053f-4537-b3e4-fae1f9051092bc_struct.png)아직 이해가 잘 가지 않는 부분이 있으신가요? 그렇다면 이전 글을 다시 한번 읽어보시고, 그래도 이해가 잘 안가신다면 글을 쉽게 못쓴 제 탓을 하시며 댓글/쪽지로 질문을 주심 성심성의껏 설명해드리도록 하겠습니다.

다음 글부터는 이 기본 구조에 살을 붙여보도록 하겠습니다. 동시에 여러 곳에서 블록을 만들어내면 어떻게 되는지, 블록체인이 뭐때문에 안전하다고 하는건지, 저걸 깰 방법은 없는지, 마이닝풀이라는게 있다는데 그건 어떻게 작동하는건지 등등에 대한 것들이 되겠네요. 그럼 다음 글에서 뵙겠습니다.


안녕하세요 야심한 밤 공부하다가 하기싫어 글쓰러 왔습니다. 저번 글에서 블록을 만들어 체이닝하는 것을 소개해드리면서 기본적인 블록체인의 구조는 설명이 끝났습니다. 그런데 이게 안전하다 안전하다 하는데 왜때문에 안전한지 제대로 설명을 드리지 않은 것 같아 이번 글에서는 안정성 위주로 설명을 드려볼까 합니다. 그 전에 블록체인 네트워크가 어떻게 다수결로 체인을 동기화하는지부터 설명을 드리는 게 이해에 도움이 될 것 같네요.

  

**1. 합의(consensus)**

블록체인 네트워크는 주기적으로(보통 새 블록이 생성돼 전파되는 시점) 체인을 동기화하며 어떤 체인을 메인 체인으로 가지고 갈 지 동기화합니다. 이를 **합의 매커니즘**이라고 하는데요, 저마다의 블록을 캐는 노드들이 어떻게 모든 내용을 복붙하지 않고 합의에 이르러 같은 체인을 유지하는지 설명드리겠습니다. 사실 이건 별로 대단한 매커니즘이 있지는 않아요. 그냥 어떤걸 고를 지 같은 원칙을 가지고 움직이면 결국 하나로 모이게 되거든요. 기본적으로 모든 노드는 "**가장 많은 노력이 든 체인**" 을 메인 브랜로 선택합니다. 다른 브랜치는 메인 브랜치가 될 가능성이 있지만 아직 메인 브랜치가 되지 못한 채로 있다가 사라지기도 하고, 메인 브랜치로 승격되기도 합니다. 이 메인 브랜치를 고르는 단 하나의 원칙 "가장 많은 노력이 든 체인을 메인 브랜치로 한다"를 따르게 되면 결국 모든 노드는 같은 브랜치를 메인 브랜치로 하게 되겠죠? 왜냐하면 시간이 지나면 결국 모든 블록 데이터를 모든 노드가 공유하게 될 테니까요. 거기서 가장 많은 노력이 든 브랜치를 고르면 같은 녀석이 나올 수밖에 없겠죠. 여기서 가장 많은 노력이라 함은 체인의 길이가 길거나, 길이가 같은 경우 블록의 크기가 더 큰(더 많은 Tx를 포함하고 있는) 것을 뜻합니다. 체인의 길이가 길다는 것은 블록이 많다는 것이고, 그 블록을 캐기 위해 더 많은 컴퓨팅 파워를 사용했기 때문에 이를 우선적으로 택하는 것이고, 거래가 많다는 것은 블록체인의 빠른 검증을 위해 유리하기 때문에 이를 택하는 것이죠. 이런 식으로 모든 노드는 결국 같은 브랜치를 하나의 메인 브랜치로 선택하게 됩니다.

  

**2. 브랜치 생성-합의 시나리오**

블록이 여러 군데에서 거의 같은 시간에 발견되는 경우에 어떻게 합의에 이르는지 살펴보도록 할게요. 이 설명을 보시면 위에서 설명한 합의 매커니즘이 좀 더 이해가 가실거에요.

  

1) N-1번 블록을 부모로 한 **N_A, N_B** 블록이 동시에 아주 먼 곳(지리적으로 먼 곳이 아닌 P2P 토폴로지상으로 먼 곳)에서 채굴되었습니다.

2) 일정의 시간이 지나 전 세계의 절반 노드는 N_A의 생성 정보를 수신했고 나머지 절반은 N_B 블록의 생성 정보를 수신했습니다. 이 시점에서 세계의 **절반은 N+1_A**를 만들기 시작했을 것이고, 나머지 **절반은 N+1_B**를 만들기 시작했습니다.

3) 시간이 좀 더 지나 전 세계에 N_A, N_B 블록의 생성 정보가 전달되었습니다. 이때 각각의 노드는 자기가 먼저 받은 블록 옆에 형제처럼 **새로 받은 블록을 가지쳐**놓고(브랜치) 일단 하던 일을 합니다.

4) 어느 시점에서 **N+1_A가 채굴**되었고, 이 정보가 전 세계에 전달되었습니다.

5) N_A를 먼저 받았던 노드들은 이 뒤에 자연스럽게 N+1_A를 이어 붙이고 바로 N+2_A를 채굴하기 시작합니다. 이들에게는 **N - N_A, N+1_A**가 한 줄기로 자연스럽기 때문에 여전히 메인 브랜치는 A 브랜치입니다.

6) N_B를 먼저 받았던 노드들은 N+1_A를 N_A 뒤에 이어붙이고 **N_B보다 N_A가 더 큰 노력**이 들었다는 것을 확인합니다. 그리고 이 노드들은 **A 브랜치를 메인 브랜치로 선택**하고 즉시 N+1_B를 만들던 작업을 중지합니다. 이제 B 브랜치는 메인이 아니니 유지할 필요가 없거든요. 그리고 N+1_A를 부모로 하는 N+2_A를 만들기 시작합니다.

7) 이제 전 세계는 같은 브랜치를 메인 브랜치로 가지는 **합의에 도달**합니다.

  

뭔가 되게 아무것도 아닌데 놀랍게 합의에 도달하죠? 이렇게 거의 동시에 같은 블록을 채굴하는 경우는 생각보다 자주 일어나지 않는다고 합니다. 그리고 브랜치가 또 브랜치를 갈라서 가지가 아주 복잡해지는 경우는 거의 발생하지 않는다고 해요. 보통은 브랜치가 2단계가 되기 전에 합의에 도달한다고 합니다.

  

**3. 블록체인의 변조 저항성**

블록체인은 그 자체로 변조에 저항성이 있습니다. 이를 설명하기 위해 몇 가지 사항들을 되짚어보도록 할게요.

1) 비트코인 블록은 대략 **10분에 한개정도 채굴**된다.

2) 비트코인 블록을 만드는 작업은 **해시**를 찾는 작업이다.

3) 해시를 찾는 방법은 **무작위 대입**밖에 답이 없다.

4) 해시함수의 특성상 입력값이 조금만 바뀌어도 **결과값은 예측 불가능하게 변한다**.

뭐... 이것만 봐도 블록 자체의 안정성이 어떻게 확보되는지 이해가 가시는 분들도 있을 것 같긴 하지만, 예를 들어 설명해드리면 이해가 더 쉬울 것 같네요.

  

내가 친구에게 3BTC를 주고(현재 시세 기준 약 천만원) 중고차를 친구에게 구입했어요. 내가 발행한 트랜잭션이 N-2번 블록에 있고, 지금 마이너들은 N+1번 블록을 찾는 중이라고 가정해봅시다. 친구는 그걸 확인하고 제게 차키를 줬습니다. ~~이제 이 차는 제껍니다.~~ 그런데 난 내 트랜잭션의 output을 조작해 내가 낸 돈이 친구가 아닌 나에게 되돌아오게 하고 싶어요. 이를 위해 **트랜잭션의 output을 변경**합니다. 그랬더니 **N-2번의 해시값이 변경**되면서 더이상 **난이도 조건**을 만족하지 않게 됐어요. 다행히 난 대학 연구원이라 슈퍼컴퓨터를 사용할 수 있어서 연구실 컴을 몰래 돌려(그러면 안됩니다) N-2번 블록의 해시를 다시 찾아냈어요. 음? 그렇게 해놓고 보니 **N-1번 블록의 입력값에 N-2번 블록의 해시값이 들어가**기 때문에 N-1번 블록의 해시값도 변경돼버렸네요. 또 연구실 컴을 돌려 N-1번 블록을 새로 만들어냅니다. 그랬더니 **N번 블록도** 같은 작업을 해줘야 해요. N번 블록까지 열심히 캐놓고 보니 N+1번 블록이 채굴됐다는 정보가 들어오네요. 하지만 내가 받은 N+1번 블록은 내가 만든 N번이 아닌 네트워크가 공유하고 있는 N번 블록의 자식이기 때문에 내 거래를 메인 브랜치로 심으려면 난 N+1번 블록도 새로 캐야 해요. 운좋게 내가 N+1번 블록과 N+2번 블록을 누구보다 빠르게 채굴했어요. 그리고 난 그 정보를 네트워크에 공유해 **내가 변조한 체인이 메인 브랜치가 되도록** 해요. 성공! 연구실 슈퍼컴퓨터를 몰래 돌린 결과 난 3BTC를 다시 내 지갑으로 되돌리면서 친구에게서 차를 받았어요.

  

자, 말로는 되게 금방 뚫리는 것 같은 위의 시나리오가 얼마나 골때리는 일인지 살펴보도록 하죠. 우선 비트코인은 전세계 수많은 컴퓨터들이 동시에 해시를 찾기 위한 쇼를 한 결과로 하나의 블록을 만들어냅니다. ASIC 채굴기가 나오면서부터 비트코인은 난이도 인플레가 심해져서 이제는 세계의 어떠한 단일 컴퓨터도(슈퍼컴 포함) 10분 안에 블록을 캐낼 수 없을 정도라고 합니다. 지금의 블록은 오로지 집단 노가다의 산물인거죠. 따라서 여러분이 정말 부자 내지는 정말 고학력자라서 슈퍼컴이고 뭐고 맘대로 갖다 쓸 수 있다고 해도 블록을 다시 캐는 속도는 새 블록이 생기는 속도보다 거의 확실하게 느리다는 말이죠. 운 좋게 한두개의 블록은 10분 안에 채굴할 수도 있겠지만, 통상적으로 고가의 거래 내지는 고도의 신뢰가 필요한 거래는 6번 이상의 컨펌을 거칩니다. 이 말은 다시 말하면 이 거래를 변조하기 위해 6개의 블록을 다시 채굴해야 한다는 말이에요. 단일 컴퓨터로 N-6부터 시작해서 N+M까지의 블록을 따라잡아 채굴한다? 가능할 것 같지 않을 시나리오죠? 이런 식으로 블록체인에 한번 명시된 거래는 사실상 변조가 불가능합니다. 이게 블록체인이 신뢰를 주는 이유지요. 물론 방금 캔 블록에 있는 거래는 변조할 수 있습니다만, 1컨펌만으로 거래를 성사시킬 정도의 금액이라면 저렇게 큰 노력을 들이는 게 의미가 없겠죠?

  

**4. 51% 어택**

그럼 이런식으로 생각해볼 수 있을 것 같네요. "**단일 컴퓨터로 안되면 네트워크를 통째로 갖다 쓰면 되잖아?**" 네 맞아요. 위에서 말했듯 새 블록이 생기면 전 세계 노드들이 어떤 걸 메인 브랜치로 가져갈 지 선택한다고 했죠? 그럼 내가 전세계 노드의 절반 이상을 내가 변조한 블록을 고르도록 하면 내가 의도한대로 모든 거래를 변조할 수 있게 되는거죠. 이걸 51% 어택이라고 해요. 실제로는 51%까지 필요가 없다고 하더라구요. 노드들이 블록을 전파하는 시간도 있고, 내 브랜치 위에 블록이 한두개만 더 올라가도 거의 확실하게 메인 브랜치가 굳어지기 때문에 그렇다고 해요. 그런데, **내가 조작할 수 있는 거래는 오로지 내 거래뿐**입니다. 내가 사인해서 잔고를 사용할 수 있는건 내 지갑에 있는 돈뿐이니까요. 한마디로 51% 네트워크를 동원해서 할 수 있는게 겨우 한 사람의 거래 조작이라는 겁니다. 그리고 이걸 변조해서 전파에 성공했다고 했을 때, 나머지 51%-1명의 사람들의 받는 보상은 없어요. 네 없어요. 다시 캔 블록 보상이 있지 않냐구요? 이미 그건 정상 블록체인이 생성되던 시점에도 만들어지던 보상이잖아요. 물론 그 보상을 먹는 사람이 달라질 수는 있겠지만, 전세계 51% 사람들이 12.5BTC를 나눠먹으면 뭐 얼마나 떨어지겠어요? 그렇다고 이 난리를 치는 사람이 자기 거래 변조하면서 전세계 51% 사람들에게 자기가 거래를 변조해 얻은 이익을 나눠줄까요? 나눠먹으면 얼마나 되겠어요. 51% 사람들은 아무 보상도 없이 좋다고 누군가의 거래 하나를 조작하기 위해 자기 컴퓨팅 파워를 기꺼이 바쳐줄까요? 말도 안 되는 얘기죠? 물론 비트코인 초기에, 노드 갯수가 얼마 되지 않아 강력한 컴퓨팅 파워를 지닌 노드가 대부분의 블록을 채굴하던 시절에는 그 노드가 맘만 먹으면 블록을 변조할 수 있었겠지만, 이런건 코인 발행 초기에 발행인이 노드를 많이 만들어놓으면 해결할 수 있는 문제여서 사실상 이런 사태가 일어날 수는 없다고 봐도 무방해요.

  

이번 글은 좀 짧네요. 간단하게 일어날 수 있는 거래 조작 시나리오와 이에 대해 블록체인이 얼마나 안정성을 지니고 있는지 살펴봤습니다. 유일하게 블록체인을 조질 수 있는 방법은 SHA256 해시를 예측하거나 매우 빠른 시간에 찾아낼 수 있는 방법을 찾는 건데, 지금까지 알려진 방법은 rainbow table 밖에는 없어요. fait 팀도 저런건 못만듭니다. 물론 SHA256 레인보우 테이블을 만드는 데 드는 시간은 비트코인의 수명이 다하는 것보다 훠어어어어얼씬 느릴 것이구요. (그래서 일각에서는 NSA 같은데서 SHA256 rainbow table을 만들려고 비트코인을 만든게 아니냐는 음모론(?)도 제기하고 그럽니다. 만든사람이 누군지 모르니 뭘 끼워넣어도 말은 되는거죠 ㅎㅎ) 어쨌든 아직까지는 뚫을 수 없는 해시함수를 보안에 사용하고 있고, 심지어 이게 체인을 이루고 있어 블록체인의 방어력은 무시무시합니다. 다음 글에서는 이렇게 블록에 실린 거래가 어떻게 검증되는지 알아보도록 하겠습니다.



안녕하세요 이번 글에서는 거래에 대해 집중적으로 살펴보려 합니다. 다들 앞에서 보셔서 기본적인 내용은 아실거라 생각합니다. 내 잔고에 사인을 해서 사용한다. 그 거래는 블록에 실리는 것으로 검증된다. 뭐 그런 내용이요. 이번에는 거기에 있는 디테일을 하나씩 꺼내보겠습니다. 

  

보통 화폐에 대해 제기되는 두 개의 큰 문제는 다음과 같다고 합니다.

1. 그 돈이 사용자의 돈인지 어떻게 증명하는가?

2. 그 돈이 다른 곳에서 쓰이지 않았다는 것을 어떻게 증명하는가? (이중지불)

우리가 흔히 쓰는 현금을 생각해보겠습니다. 1번에 대해서는 사실상 완벽한 증명이 불가능하죠. 하지만 내 통장에 있는 돈을 은행에 가서 현금으로 찾았고, 그 영수증과 거래기록이 남아있음을 보여준다면 그 돈이 내것이라는 것을 증명하는 것은 불가능하지 않습니다. 2번에 대해서는 아주 명확하죠? 현금은 계산을 위해 지불하는순간 내게서 사라져 상대방에게 전달되기 때문에 같은 돈을 다른데서 쓰고 와서 또 쓸 수가 없습니다. 이중지불이란 말 자체가 생소한건 우리가 겪을 수 없는 상황에 가깝기 때문입니다. 그럼 블록체인 기반의 암호화폐는 어떻게 이 문제를 해결할까요?

  

**0. 공개키 암호화(비대칭 암호화)**

글을 쓰다보니 공개키 암호화가 뭔지 설명을 좀 해야 이해하시기 수월할 것 같다는 생각이 들어서 0번 섹션을 추가했습니다. 어렵게 들어가지는 않고 개념적으로, 아래에서 설명하는 내용에 집어넣을 수 있을 정도로만 설명드릴게요. 보통의 암호화 방법은 암호화 키라는 것을 가지고 평문을 암호문으로 만듭니다. 그리고 이 키를 가지고 역연산을 해서 복호화를 하는데요, 하나의 키로 암호화와 복호화를 둘 다 하기 때문에 대칭키 암호화 방식이라고 합니다. 이 방식의 장점은 키를 생성하고 암호화/복호화를 하는데 드는 노력이 상대적으로 적다는 것이구요, 단점은 이 키로 암호화/복호화를 둘 다 할 수 있기 때문에 키가 탈취되면 이 암호키를 사용한 암호체계가 몽땅 망가집니다.

이 방식을 개선하기 위해 나온 게 비대칭 암호화 또는 공개키 암호화 방식이라고 하는데요, 이건 키가 두 개 존재합니다. 먼저 일반적인 방식으로 암호 키를 생성합니다. 이 키는 나만 들고있는 개인키가 됩니다. 그리고 이 개인키에 적당한 연산을 해서(보통 타원곡선곱셈함수 같은걸 쓴다고 합니다) 개인키에서 도출한 또 하나의 키를 생성합니다. 이 키는 공개키라고 불리며, 이 키는 공개해놓고 모두가 공유합니다. 암호화 키를 공유한다니 이상하죠? 그런데 신기한 게 공개키를 안다고 해서 개인키를 역연산으로 찾아내는 것은 불가능하다고 하네요. 쉽게 생각하면 SHA256 collision을 찾는 정도의 난이도라고 보시면 됩니다. 그래서 개인키에서 공개키를 만들 수는 있지만 공개키에서 개인키를 만들 수는 없습니다. 그리고 이 암호화 기법의 신기한 점은 개인키로 암호화한 암호문은 공개키로만 풀 수 있고, 공개키로 암호화한 암호문은 개인키로만 풀 수 있다는 겁니다. 어느 하나만 가지고는 암호화/복호화를 할 수 없는거죠. 그래서 비대칭이라는 이름이 붙습니다. 

기본적인 시나리오는 다음과 같습니다. 내가 친구에게 편지를 보내고자 하면 편지를 써서 친구가 공개해놓은 공개키로 암호화를 합니다. 그리고 친구에게 보내는거죠. 친구는 자신의 개인키를 가지고 있을테니 이 암호문을 풀 수 있습니다. 하지만 다른사람은 이 암호문을 탈취해도 풀 수 있는 방법이 없네요. 친구는 내게 제가 공개해놓은 공개키로 암호화한 답장을 보내고, 전 제 개인키를 이용해 이를 복호화합니다. 

네 아주 신기하고 강력한 방법이죠? 아래의 글을 읽기 위해 기억해야 하는 것은 이것밖에 없습니다. 개인키와 공개키 두 개를 한번씩 사용해야 암호화/복호화를 할 수 있다. 그럼 이걸 가지고 본격적인 내용을 살펴보겠습니다.

**1. 잔고의 증명**

비트코인은 우리가 흔히 아는 지갑처럼 담겨있는 잔고를 꺼내서 쓰는거에요. 쉽게 생각하면 그렇지만, 이게 사실은 그렇지 않습니다. 정확히 말하자면 우리가 만든 비트코인 지갑에 비트코인은 1사토시(1억분의 1 BTC로, 비트코인의 최소단위)도 들어있지 않아요. 이게 무슨소리냐면, 결국 모든 거래는 블록에 담기잖아요? 그 거레 내용에 보면 input, output이 있는데, input은 그 거래를 위해 지불한 금액이 들어가고, output에는 그 지불한 돈의 소유권이 누구에게 이전되는지에 대한 정보가 들어갑니다. 내 돈이 어디서 왔고 그럼 그 돈은 어디서 왔고... 를 자꾸 생각하면 어려우니까 아주 쉽게 내가 채굴보상으로 받은 돈을 사용한다고 생각해봅시다.

내가 새 블록을 채굴했어요. 그래서 블록 채굴에 대한 보상으로 12.5 비트코인을 받았습니다(축하드립니다 소나타를 사실 수 있겠네요). 이 블록의 맨 첫 거래는 코인베이스 거래라는 것으로, input 없이 output만 존재하는 유일한 거래입니다. 무에서 유를 창조하는 거래죠. 여기에는 output에 내 지갑 주소가 적혀있어요. 네 내 돈이라는 뜻입니다. 근데 이게 내 돈인지 어떻게 알죠? 이 돈을 누가 훔쳐가며 어떡하죠? 블록체인에서 잔고의 증명은 다음과 같이 할 수 있습니다.

모든 지갑은 자신의 주소를 가지고 있습니다. 이 주소는 조금 변조된 공개키라고 볼 수 있어요. 그래서 거래의 output에 이 사람이 주인이라고 하기 위해 그 액수에 해당하는 데이터를 이 사람의 지갑 주소로 암호화해버립니다. 그럼 이 돈을 꺼내기 위해서는 복호화를 해야 하는데, 그걸 누구만 가능해요? 개인키를 가진 사람만 가능하겠죠? 이런 식으로 블록체인 시스템이 잔고의 소유자를 증명합니다. 다른 사람은 암호화된 잔고 데이터를 봐도 열지를 못해요. 개인키는 나만 가지고 있으니까요. 이렇게 나만 사용할 수 있도록 남아있는 output들의 모임을 UTXO(Unused Transaction Output) 이라고 합니다. 지갑에 표기되는 잔고는 내 개인키로 풀 수 있는 UTXO들의 모임이에요. 돈을 사용하면 이 UTXO에 내 개인키로 사이닝을 해서(암호를 풀어서) input에 집어넣게 됩니다. 그리고 이 돈을 받게될 사람의 지갑 주소로 암호화해서 output에 넣는거죠. 이런식으로 소유권이 계속 옮겨가면서 또 다른 누군가의 UTXO가 됩니다.

**2. 거래의 증명(이중지불 검증)**

그럼 또 하나의 이슈인 이중지불 문제를 생각해보죠. 이 문제는 더 해결하기 쉬워요. 노드가 새 거래 정보를 전달받았을 때 우선 검증을 한 뒤에 Tx. Pool에 들어간다고 했었죠? 이 검증에는 input에 들어있는 UTXO가 이전에 쓰인 적이 있는지를 확인하는 것도 포함되어 있어요. 이전 블록중에 input에 들어있는 UTXO가 사용된 적이 있다면 이 거래를 무효라고 하고 거절하면 되겠죠? 이런 식으로 블록체인은 이중지불에 대한 문제도 쉽게 해결할 수 있습니다.

이와는 조금 별개로, 거래 자체가 잘못된 거래가 아닌지는 어떻게 확인할까요? Full Node 같은 경우에는 쉽습니다. 모든 거래기록을 내가 다 가지고 있기 때문에 그냥 그 거래가 들어있는 블록의 Body 안에 있는 거래 정보를 확인하고, 블록의 해시값이 우리가 알고있는 해시값과 같은지 확인하면 돼요. 그러면 이 거래가 존재하고 유효하다는 것을 증명할 수 있죠.Lightweight Node 같은 경우에는 모든 블록 데이터가 아닌 헤더만 가지고 있다고 했었죠? 그럼 이 경우에는 어떻게 알 수 있을까요? SPV 라는 방법을 이용해 검증하는데, 한 가지는 내가 검증하고자 하는 거래가 든 블록의 깊이를 확인하는 겁니다. 다시 말해 내가 보고자 하는 블록 뒤에 몇 개의 블록이 더 생성됐나를 보는거죠. 다시 계산해야 할 블록이 많을수록 변조가 어려워지니까요. 또 다른 하나는 Merkle Tree(머클 트리라고 합니다)를 만들어보는 겁니다. Lightweight Node는 주변의 Full Node에게 이 거래와 같은 블록에 있는 거래들의 Hash 정보를 요청합니다. 이걸 가지고 Merkle Tree를 만드는데요, 트리의 최상위 값인 Merkle Root가 블록 헤더에 있는 Merkle Root 값과 일치하는지 확인합니다. Merkle Tree는 쉽게 말하면 거래의 해시를 두개씩 묶어서 또 해시를 만들고, 이걸 묶어서 또 해시를 만들고... 를 반복한 것을 말해요. 그러면 단계를 반복할수록 갯수가 적어지는 구조가 되겠죠? 토너먼트 대진표처럼요. 맨 위에는 1개만 남게 될 것이구요. 이 값이 블록 헤더에 들어가는 Merkle Root라는 값입니다. 해시는 값이 조금만 변경돼도 예측할 수 없이 변하기 때문에 거래가 변조되었다면 제대로 된 Merkle Tree가 생성되지 않겠죠? 당연히 루트의 값도 다를것이구요. 이런 방식으로 Lightweight Node는 필요할 때마다 주변 Full Node에게 약간의 정보(해시 몇개만 받으면 되니까요)를 받아서 거래를 검증할 수 있습니다.

  

뭔가 거래만 확인하면 되는 것 같은데 공개키 암호화부터 시작해서 머클트리니 뭐니 하는 어려운 것들이 잔뜩 붙어버렸네요. 이번 글은 말 그대로 심화과정이었습니다. 몰라도 큰 문제는 없지만 내부가 어떻게 되어있는지 구체적으로 알려면 필요한 그런 내용들이었죠. 아마 교양글로 읽기에는 적합하지 않을 것 같기도 합니다만, 기왕에 쓰는거 가능한 많은 범위를 커버하는 것이 좋다고 생각해 조금 무리해서 글을 작성해봤습니다.

  

이정도면 대충 블록체인 기술에 대해 다 설명을 드린 것 같네요. 10편까지 써야되나 하고 있었는데 애매하게 7편 정도에서 글이 마무리될 것 같습니다. 제가 까먹고 설명드리지 않은 부분이 있다면 알려주세요 기꺼이 8편 또는 그 이상의 글을 써드리도록 하겠습니다. 며칠 기다려보고 더 쓸 내용이 없는 것 같다 싶으면 총정리글을 한개 올리고 마무리짓도록 하겠습니다. 댓글과 쪽지는 언제나 환영합니다.

이번 글에서는 지난 7편의 글에서 다뤘던 모든 내용을 묶어서 하나의 스토리로 엮어볼 생각입니다. 유저레벨에서부터 블록체인 뒷단까지를 오가면서 이야기를 진행할 예정이라 앞의 글을 다 읽고도 조각이 맞춰지지 않는 게 있던 분들은 그 고리가 여기서 이어지길 바랍니다. 모르는 용어가 있으시다면 앞의 글을 찾아보시면 나와요.

  

- 이 이야기는 A라는 사람이 비트코인 지갑을 생성해 물건을 구매하는 과정을 이야기합니다.

- 그리고 B라는 해커가 비트코인 네트워크를 공격하고 비트코인을 채굴하는 과정을 이야기합니다.

- 갑자기 도박꾼 X, Y, Z 가 지나갑니다.

  

**0. 계좌의 생성**

A는 요새 인터넷만 했다 하면 비트코인 얘기가 나와서 그게 뭔지 알아보고 한번 써보기로 했다. 비트코인 지갑을 생성할 수 있는 방법은 많지만, A는 간편하게 비트코인을 얻기 위해 거래소에 계정을 만들고 지갑을 생성했다. 그리고 내 비트코인을 저장할 개인 지갑을 또 한개 만들었다. 

계정을 생성하면 블록체인 노드에서 공개키 알고리즘을 이용해 키를 생성하고, 개인키를  A에게 전달해준다. 이 개인키는 A의 공개키로 잠긴 UTXO를 해제할 수 있는 유일한 키로, 이 돈이 내 돈이라는 것을 증명하는 역할을 한다.

이 키는 분실되면 지갑을 다시 열 수 없기 때문에  A는 이 키를 복사해 다른 곳에 백업해두었다.

  

**1. 거래의 생성**

거래소에서 얼마간의 돈을 주고 비트코인을 구입한 A는 모 사이트에서 비트코인으로 물건을 구매할 수 있다는 것을 알고는 실제로 비트코인을 이용해 물건을 구입해보기로 했다. 결제화면에 나타난 지갑 주소를 받는 사람으로 해 A는 자신의 지갑에서 물건대금에 해당하는 만큼의 비트코인을 전송했다. 

이 작업이 이루어지면 내 클라이언트에서는 내 개인키를 이용해 UTXO를 풀어 하나의 Transaction을 생성한다. 이 안에는 보내는사람, 받는사람, input, output, extra data 등이 들어있다. 클라이언트에서는 이 정보를 자신에게 연결되어 있는 주변 P2P Node 들에 전송하고, 이는 곧 블록체인 네트워크 전체로 퍼진다. 새 거래를 전송받은 Full Node 에서는 이 거래가 적합한 거래인지 검증하고, Tx. Pool에 넣어놓는다.

  

**2. 거래의 승인**

A는 비트코인을 보내고 거래가 완료되었다는 메세지를 기다리고 있다. 비트코인의 블록은 평균 10분에 한개 생성되기 때문에 1번의 승인을 받기까지 대략 10분 정도의 시간이 소요된다. A가 구매한 물건은 그다지 비싸지 않기 때문에 1번의 승인이 일어나면 거래를 완료시킨다. 

같은 시각, 어딘가의 Full Node가 Tx. Pool 안에서 거래들을 꺼내 새 블록을 만들기 시작했다. A의 거래는 수수료를 높게 책정해 이 블록에 바로 포함되었다. 블록 안에는 이전 블록의 해시, timestamp, difficulty, nonce, merkle root, Tx. Info 들이 들어있으며, 이 Full Node는 현재의 채굴 난이도에 적합한 해시를 만들기 위해 nonce를 바꿔가며 brute force로 블록을 마이닝한다. 운 좋게 이 Node가 가장 빨리 블록을 생성했고, 곧 찾아낸 nonce 값을 블록에 기록한 뒤 새 블록을 생성했음을 주변 Node 들에 전파한다. 주변 Node에서는 새 블록을 받으면 이 블록이 맞는지 검증하고 자신이 하던 작업을 중지, 받은 정보를 기반으로 새 블록을 생성하기 시작한다. 

이렇게 블록이 생성되었다는 것이 네트워크에 전파되어 A는 거래가 완료되었다는 메세지를 받게 됐고, 며칠 뒤 A는 구매한 물건을 배송받았다.

  

**3. 거래의 검증**

A는 며칠 뒤 같은 상점에서 다른 물건을 또 구매하는데, 이 시점에서 A의 지갑은 UTXO를 사용하기에 앞서 이 UTXO를 생성한 이전 거래가 유효한 거래인지 검증하고 UTXO를 사용하게 된다. 

A의 컴퓨터에 있는 개인 지갑은 Lightweight Node 이기 때문에 블록의 모든 정보를 받지 않고 블록 헤더만 저장한다.  A의 지갑 역시 새 거래나 블록을 전달받으면 유효성을 검증하게 되는데, Full Node와 달리 Lightweight Node는 주변의 Full Node에게 해당 블록의 merkle tree 정보를 요구해 거래의 유효성을 검증한다. 이 시점에서 A가 첫 물건을 살 때 발생한 거래가 든 블록은 매우 깊이 있기 때문에(비트코인의 경우 24시간에 대략 144개의 블록이 생성된다) 신뢰성이 보장되며, 주변 Full Node에서 받은 결과를 토대로 거래 자체도 유효함이 검증되었다. 이렇게 SPV 방식으로 거래를 검증한 A의 지갑은 또 다시 거래를 생성해 주변 노드에 전파한다.

  

**4. 블록체인의 안정성**

해커 B는 비트코인 가격이 300만원을 넘어선 것을 보고 블록체인을 해킹해 비트코인을 소유해보려 한다. 비트코인 블록체인이 어떻게 이루어졌는지 확인해본 B는 두 가지 공격 방법을 생각해낸다. **하나는 51% 어****택**이고, **하나는 더 빠른 채굴**이다. 

B는 첫번째 방법을 실현하기 위해 주변 해커들에게 비트코인 네트워크 전체의 51%에 해당하는 컴퓨팅 파워를 얻으려면 어떻게 해야 하는지 물어봤다. 50%를 넘는 컴퓨팅 파워를 가지고 있으면 메인 브랜치를 내가 원하는 대로 지정할 수 있기 때문이다. 동료들은 단일 기기에서는 그정도 파워를 얻을 수 없으며, 중국의 거대 채굴장을 몇개 모으면 51%에 가까운 파워를 얻을 수 있다고 답한다. 그러나 그들은 자신들이 얻어가는 이익이 다른 사람에게 파워를 제공해서 얻을 수 있는 이익보다 크기 때문에 B에게 협조하지 않을 것이라고도 한다. B는 곧 51% 어택을 포기하고 빠른 채굴로 다른 사람보다 앞서 블록을 만들어 B의 브랜치를 메인 브랜치로 바꾸려는 전략을 구상한다. 남들보다 월등하게 빠른 채굴 능력을 가지게 되면 보상도 독점할 수 있고 원한다면 이전 블록을 다시 마이닝해 메인 브랜치를 교체할 수도 있기 때문이다. 비트코인 블록체인은 SHA256 해시를 이용하고 있기 때문에 B는 이를 점령하면 마음대로 브랜치를 조종할 수 있다고 생각하고, SHA256에 대한 공격 방법을 찾는다. 하지만 B는 곧 이 방법도 포기하게 되는데, 아직까지 SHA256에 대한 공격 방법은 존재하지 않으며, 몇몇 보고된 성공 사례들은 범용적으로 적용하기에는 너무도 일부의 케이스만을 다루고 있기 때문이다. 

해커 B는 블록체인의 안정성에 혀를 내두르며 중고나라에 로동자 에디션으로 나온 그래픽카드를 사러 간다.

  

**5. 마이닝 풀(Mining Pool)**

B는 중고나라에서 싸게 업어온 로동자 에디션 그래픽카드를 이용해 비트코인을 채굴해보기로 한다. 블록체인의 보상은 기본적으로 블록을 채굴한 사람이 모두 가져가게 되어 있는데, 개인이 블록을 캐는 것은 거의 불가능에 가깝기 때문에 B는 마이닝 풀을 이용해 적지만 지속적인 수입을 얻어보려 한다. 

마이닝 풀에 접속한 B의 컴퓨터는 마이닝 풀로부터 새로 생성할 블록의 헤더만을 전달받는다. 이를 이용해 난이도에 맞는 해시를 찾는데, 마이닝 풀에서 제공하는 난이도는 통상적으로 블록의 난이도보다 1000배정도 쉽다. B의 컴퓨터는 마이닝 풀이 제공한 난이도에 적합한 해시를 찾으면 이를 마이닝 풀에 알리는데, 이를 PoW(Proof of Work) 라고 한다. 

여러 사람이 주사위를 각자 3개씩 던져 4 이하가 제일 먼저 나오는 사람이 이기는 게임이 있다고 해보자.  X 혼자서 3개의 주사위로 4 이하의 값이 나오게 하기는 쉽지 않기 때문에 X는 Y, Z를 불러 같이 주사위를 던지며 이 게임에 승리하려 한다. 대신에 보상을 적절한 비율로 나눠가지기 위해 3개의 주사위를 던져 6 이하의 값이 나온 횟수를 세서 이 비율대로 상금을 나눠가지기로 한다. 물론 X, Y, Z가 4 이하의 값을 만들기 전에 누군가 값을 만들 수도 있지만 혼자보다는 셋이 주사위를 던지는 게 성공 확률이 높을테니 X는 상대적으로 보상은 적지만 안정적인 승률을 기대할 수 있다. 또 모르지 더 수익이 높을 지...

B의 컴퓨터도 이렇게 마이닝 풀의 일원이 되어 자신의 작업을 마이닝 풀에 알리고, 마이닝 풀은 일원의 누군가 블록을 생성해 보상을 받으면 각각의 마이너들이 기여한 비율대로 보상을 나눠주게 된다.

  

  

  

쓰다 보니 마이닝 풀에 대한 얘기를 쓴 적이 없어서 여기에 같이 얹어봤습니다. 마이닝 풀은 어렵지 않으니까요. 써놓고 보니 애초에 글을 이렇게 쓰는 게 더 이해가 쉽지 않았을까 하는 생각이 드네요...흠...

  

어쨌든 이렇게 블록체인에 대한 모든 내용이 마무리되었습니다. 모쪼록 도움을 받으시는 분이 계시면 좋겠네요. 다음에 또 제가 꽂히는 분야가 생기면 이런 식으로 불쑥 나타나 또 툭 던지고 사라지도록 하겠습니다. 그럼 그때까지 다들 즐거운 날 보내세요.